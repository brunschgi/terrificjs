<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns:yui="http://yuilibrary.com/rdf/1.0/yui.rdf#">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<title>API: Tc   terrific-1.0.0.js  (TerrificJS)</title>

	<link rel="stylesheet" type="text/css" href="assets/reset-fonts-grids-min.css?stamp=1312465620.74" />
	<link rel="stylesheet" type="text/css" href="assets/api.css?stamp=1312465620.74" />

    <script type="text/javascript" src="assets/api-js?stamp=1312465620.74"></script>
    <script type="text/javascript" src="assets/ac-js?stamp=1312465620.74"></script>
</head>

<body id="yahoo-com">

<div id="doc3" class="yui-t2">
	<div id="hd">
        <h1><a href="http://www.terrifically.org" title="Terrific JavaScript Framework">Terrific JavaScript Framework</a></h1>
        <h3>Tc&nbsp; <span class="subtitle">1.0.0</span></h3>
        <a href="./index.html" title="Terrific JavaScript Framework">Terrific JavaScript Framework</a> 
            &gt; <a href="./module_tc.html" title="Tc">Tc</a>
                
                 &gt; terrific-1.0.0.js (source view) 
        <form onsubmit="return false">
            <div id="propertysearch">
                Search: <input autocomplete="off" id="searchinput" />
                <div id="searchresults">
                    &nbsp;
                </div>
            </div>
        </form>
	</div>

	<div id="bd">
		<div id="yui-main">
			<div class="yui-b">
            <form action="#" name="yui-classopts-form" method="get" id="yui-classopts-form">
                <fieldset>
                    <legend>Filters</legend>
                <span class="classopts"><input type="checkbox" name="show_private" id="show_private" /> <label for="show_private">Show Private</label></span>
                <span class="classopts"><input type="checkbox" name="show_protected" id="show_protected" /> <label for="show_protected">Show Protected</label></span>
                <span class="classopts"><input type="checkbox" name="show_deprecated" id="show_deprecated" /> <label for="show_deprecated">Show Deprecated</label></span>
                </fieldset>
            </form>

                    <div id="srcout">
                        <style>
                            #doc3 .classopts { display:none; }
                        </style>
<div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Terrific JavaScript Framework v1.0.0</span>
<span class="cm"> * http://terrifically.org</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2011, Remo Brunschwiler</span>
<span class="cm"> * MIT Licensed.</span>
<span class="cm"> *</span>
<span class="cm"> * Date: Thu, 04 Aug 2011 13:46:59 GMT</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Includes:</span>
<span class="cm"> * Simple JavaScript Inheritance</span>
<span class="cm"> * By John Resig http://ejohn.org/</span>
<span class="cm"> * MIT Licensed.</span>
<span class="cm"> *</span>
<span class="cm"> * @module Tc</span>
<span class="cm"> * </span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">Tc</span> <span class="o">=</span> <span class="nx">Tc</span> <span class="o">||</span> <span class="p">{};</span>

<span class="cm">/*</span>
<span class="cm"> * The jQuery object.</span>
<span class="cm"> */</span>
<span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">noConflict</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Simple JavaScript Inheritance</span>
<span class="cm"> * By John Resig http://ejohn.org/</span>
<span class="cm"> * MIT Licensed.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">fnTest</span> <span class="o">=</span> <span class="sr">/xyz/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">xyz</span><span class="p">;</span> <span class="p">})</span> <span class="o">?</span> <span class="sr">/\b_super\b/</span> <span class="o">:</span> <span class="sr">/.*/</span><span class="p">;</span>
    
    <span class="c1">// The base Class implementation (does nothing)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">Class</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="p">};</span>
    
    <span class="c1">// Create a new Class that inherits from this class</span>
    <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prop</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">_super</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
        
        <span class="c1">// Instantiate a base class (but only create the instance,</span>
        <span class="c1">// don&#39;t run the init constructor)</span>
        <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="k">this</span><span class="p">();</span>
        <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        
        <span class="c1">// Copy the properties over onto the new prototype</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">name</span> <span class="k">in</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Check if we&#39;re overwriting an existing function</span>
            <span class="nx">prototype</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span> <span class="o">&amp;&amp;</span>
            <span class="k">typeof</span> <span class="nx">_super</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span> <span class="o">&amp;&amp;</span>
            <span class="nx">fnTest</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="o">?</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">fn</span><span class="p">){</span>
                <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
                    <span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_super</span><span class="p">;</span>
                    
                    <span class="c1">// Add a new ._super() method that is the same method</span>
                    <span class="c1">// but on the super-class</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">_super</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
                    
                    <span class="c1">// The method only need to be bound temporarily, so we</span>
                    <span class="c1">// remove it when we&#39;re done executing</span>
                    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">_super</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
                    
                    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
                <span class="p">};</span>
            <span class="p">})(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="o">:</span> <span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
        <span class="p">}</span>
        
        <span class="c1">// The dummy class constructor</span>
        <span class="kd">function</span> <span class="nx">Class</span><span class="p">(){</span>
            <span class="c1">// All construction is actually done in the init method</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">initializing</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
			<span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// Populate our constructed prototype object</span>
        <span class="nx">Class</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>
        
        <span class="c1">// Enforce the constructor to be what we expect</span>
        <span class="nx">Class</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">;</span>
        
        <span class="c1">// And make this class extendable</span>
        <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="nx">Class</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">})();</span>

<span class="cm">/**</span>
<span class="cm"> * Contains the application base config.</span>
<span class="cm"> * The base config can be extended or overwritten either via</span>
<span class="cm"> * new Application ($ctx, config), during bootstrapping the application or via </span>
<span class="cm"> * /public/js/Tc.Config.js in the project folder.</span>
<span class="cm"> *</span>
<span class="cm"> * @author Remo Brunschwiler</span>
<span class="cm"> * @namespace Tc</span>
<span class="cm"> * @class Config</span>
<span class="cm"> * @static</span>
<span class="cm"> */</span>
<span class="nx">Tc</span><span class="p">.</span><span class="nx">Config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/** </span>
<span class="cm">     * The paths for the different types of dependencies.</span>
<span class="cm">     *</span>
<span class="cm">     * @property dependencyPath</span>
<span class="cm">     * @type Object</span>
<span class="cm">     */</span>
    <span class="nx">dependencyPath</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">library</span><span class="o">:</span> <span class="s1">&#39;/js/libraries/dynamic/&#39;</span><span class="p">,</span>
        <span class="nx">plugin</span><span class="o">:</span> <span class="s1">&#39;/js/plugins/dynamic/&#39;</span><span class="p">,</span>
        <span class="nx">util</span><span class="o">:</span> <span class="s1">&#39;/js/utils/dynamic/&#39;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Responsible for application-wide issues such as the creation of modules.</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Application</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Application</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the application.</span>
<span class="cm">         *</span>
<span class="cm">         * @method init</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         * @constructor</span>
<span class="cm">         * @param {jQuery} $ctx </span>
<span class="cm">         *      The jquery context</span>
<span class="cm">         * @param {Object} config </span>
<span class="cm">         *      The configuration</span>
<span class="cm">         */</span>
        <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/**</span>
<span class="cm">             * The configuration.</span>
<span class="cm">             *</span>
<span class="cm">             * @property config</span>
<span class="cm">             * @type Object</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Config</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>

            <span class="cm">/**</span>
<span class="cm">             * The jQuery context.</span>
<span class="cm">             *</span>
<span class="cm">             * @property $ctx</span>
<span class="cm">             * @type jQuery</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span> <span class="o">=</span> <span class="nx">$ctx</span> <span class="o">||</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">);</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains references to all modules on the page.</span>
<span class="cm">             * Could be useful for example when there are interactions between</span>
<span class="cm">             * Flash &lt;-&gt; JS.</span>
<span class="cm">             *</span>
<span class="cm">             * @property modules</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">modules</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains references to all connectors on the page.</span>
<span class="cm">             *</span>
<span class="cm">             * @property connectors</span>
<span class="cm">             * @type Object</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span> <span class="o">=</span> <span class="p">{};</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains references to all wildcard components on the page.</span>
<span class="cm">             *</span>
<span class="cm">             * @property wildcardComponents</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="cm">/**</span>
<span class="cm">             * The sandbox to get the resources from </span>
<span class="cm">             * This sandbox is shared between all modules.</span>
<span class="cm">             *</span>
<span class="cm">             * @property sandbox</span>
<span class="cm">             * @type Sandbox</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Sandbox</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Register modules withing scope</span>
<span class="cm">         * Automatically registers all modules within the scope, </span>
<span class="cm">         * as long as the modules use the OOCSS naming conventions.</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerModules</span>
<span class="cm">         * @param {jQuery} $ctx </span>
<span class="cm">         *      The jQuery context.</span>
<span class="cm">         * @return {Array} </span>
<span class="cm">         *      A list containing the references of the registered modules.</span>
<span class="cm">         */</span>
        <span class="nx">registerModules</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
                    <span class="nx">modules</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="nx">$ctx</span> <span class="o">=</span> <span class="nx">$ctx</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span><span class="p">;</span>

            <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;.mod&#39;</span><span class="p">,</span> <span class="nx">$ctx</span><span class="p">).</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">$this</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

                <span class="cm">/**</span>
<span class="cm">                 * @property classes</span>
<span class="cm">                 *      A module can have three types of classes:</span>
<span class="cm">                 * @attribute .mod </span>
<span class="cm">                 *      Indicates that it is a base module (default </span>
<span class="cm">                 *      -&gt; no javascript need to be involved). Must occur</span>
<span class="cm">                 *      excactly once.</span>
<span class="cm">                 *</span>
<span class="cm">                 * @attribute .mod&lt;moduleName&gt; (e.g. .modBasic) </span>
<span class="cm">                 *      Indicates that it is a module of type basic, which is</span>
<span class="cm">                 *      derived from the base module. It can occur at most</span>
<span class="cm">                 *      once.</span>
<span class="cm">                 * @attribute .skin&lt;moduleName&gt;&lt;skinName&gt; (e.g. .skinBasicSubmarine) </span>
<span class="cm">                 *      Indicates that the module basic has the submarine skin.</span>
<span class="cm">                 *      It will be decorated by the skin js (if existing). It</span>
<span class="cm">                 *      can occur arbitrarily.</span>
<span class="cm">                 *</span>
<span class="cm">                 * @attribute data-connectors</span>
<span class="cm">                 *      Additionally, a module can have one type of data attributes:</span>
<span class="cm">                 *      A comma-separated value containing the connector ids,</span>
<span class="cm">                 *      the schema of a connector id is: </span>
<span class="cm">                 *      &lt;connectorName&gt;&lt;connectorId&gt;&lt;connectorRole&gt;</span>
<span class="cm">                 *      e.g. MasterSlave1Master:</span>
<span class="cm">                 *          name = MasterSlave, id = 1, role = Master</span>
<span class="cm">                 *      The above indicates that the module should notify the</span>
<span class="cm">                 *      MasterSlave connector (the mediator) over all state</span>
<span class="cm">                 *      changes. The connector id is used to chain the</span>
<span class="cm">                 *      appropriate modules together and to improve the</span>
<span class="cm">                 *      reusability of the connector.</span>
<span class="cm">                 *</span>
<span class="cm">                 * It can contain multiple connector ids (e.g.</span>
<span class="cm">                 * 1,2,MasterSlave1Master)</span>
<span class="cm">                 * TODO: Is this still correct? The above statement referenced</span>
<span class="cm">                 * type 1 for data-connectors</span>
<span class="cm">                 *</span>
<span class="cm">                 */</span>

                <span class="cm">/**</span>
<span class="cm">                 * @attribute classes  </span>
<span class="cm">                 *      .mod Indicates that it is a base module (default </span>
<span class="cm">                 *      -&gt; no javascript need to be involved). Must occur</span>
<span class="cm">                 *      excactly once.</span>
<span class="cm">                 */</span>


                <span class="kd">var</span> <span class="nx">classes</span> <span class="o">=</span> <span class="nx">$this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">classes</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">modName</span><span class="p">,</span>
                            <span class="nx">skins</span> <span class="o">=</span> <span class="p">[],</span>
                            <span class="nx">connectors</span> <span class="o">=</span> <span class="p">[];</span>

                    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">classes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kd">var</span> <span class="nx">part</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">trim</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="nx">part</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;mod&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">part</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">modName</span> <span class="o">=</span> <span class="nx">part</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
                        <span class="p">}</span>
                        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">part</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;skin&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                            <span class="c1">// remove the mod name part from the skin name</span>
                            <span class="nx">skins</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">part</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="nx">modName</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>


                    <span class="k">if</span> <span class="p">(</span><span class="nx">$this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-connectors&#39;</span><span class="p">))</span> <span class="p">{</span>
                        <span class="nx">connectors</span> <span class="o">=</span> <span class="nx">$this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-connectors&#39;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">connectors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">connectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">trim</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>


                    <span class="k">if</span> <span class="p">(</span><span class="nx">modName</span> <span class="o">&amp;&amp;</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">])</span> <span class="p">{</span>
                        <span class="nx">modules</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">registerModule</span><span class="p">(</span><span class="nx">$this</span><span class="p">,</span> <span class="nx">modName</span><span class="p">,</span> <span class="nx">skins</span><span class="p">,</span> <span class="nx">connectors</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">});</span>

            <span class="k">return</span> <span class="nx">modules</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Unregisters the modules given by the module instances.</span>
<span class="cm">         *</span>
<span class="cm">         * @method unregisterModule</span>
<span class="cm">         * @param {Array} modules </span>
<span class="cm">         *      A list containting the module instances to unregister</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">unregisterModules</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">,</span>
                    <span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span><span class="p">;</span>

            <span class="nx">modules</span> <span class="o">=</span> <span class="nx">modules</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">modules</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Empty everything if the arrays are equal</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">modules</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// Unregister the given modules</span>
                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                    <span class="kd">var</span> <span class="nx">index</span><span class="p">;</span>

                    <span class="c1">// Delete the references in the connectors</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">connId</span> <span class="k">in</span> <span class="nx">connectors</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connId</span><span class="p">].</span><span class="nx">unregisterComponent</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Delete the references in the wildcard components</span>
                    <span class="nx">index</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">inArray</span><span class="p">(</span><span class="nx">module</span><span class="p">,</span> <span class="nx">wildcardComponents</span><span class="p">);</span>
                    <span class="k">delete</span> <span class="nx">wildcardComponents</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>

                    <span class="c1">// Delete the module instance itself</span>
                    <span class="nx">index</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">inArray</span><span class="p">(</span><span class="nx">module</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">);</span>
                    <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Starts (intializes) the registered modules.</span>
<span class="cm">         *</span>
<span class="cm">         * @method start</span>
<span class="cm">         * @param {Array} modules </span>
<span class="cm">         *      A list of the modules to start</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">start</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span><span class="p">,</span>
                    <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">;</span>

            <span class="nx">modules</span> <span class="o">=</span> <span class="nx">modules</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="c1">// Start the modules</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">start</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="cm">/*</span>
<span class="cm">             * Special treatment for the wildcard connection (conn*) -&gt; it will</span>
<span class="cm">             * be notified about all state changes from all connections and is</span>
<span class="cm">             * able to propagate its changes to all modules. Tis must be done on</span>
<span class="cm">             * init to make sure that all connectors on the page has been</span>
<span class="cm">             * instantiated. Only do this for the given modules.</span>
<span class="cm">             */</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">wildcardComponents</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">component</span> <span class="o">=</span> <span class="nx">wildcardComponents</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">inArray</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">modules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">connectorId</span> <span class="k">in</span> <span class="nx">connectors</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// The connector observes the component and attaches it</span>
            <span class="c1">// as an observer</span>
                        <span class="nx">component</span><span class="p">.</span><span class="nx">attachConnector</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]);</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">].</span><span class="nx">registerComponent</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Stops the registered modules.</span>
<span class="cm">         *</span>
<span class="cm">         * @method stop</span>
<span class="cm">         * @param {Array} modules </span>
<span class="cm">         *      A list containting the module instances to stop.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">stop</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">modules</span> <span class="o">=</span> <span class="nx">modules</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="c1">// Stop the modules</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">stop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Registers a module.</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerModule</span>
<span class="cm">         * @param {jQuery} $node </span>
<span class="cm">         *      The module node.</span>
<span class="cm">         * @param {String} modName </span>
<span class="cm">         *      The module name. It must match the class name of the module</span>
<span class="cm">         *      (case sensitive).</span>
<span class="cm">         * @param {Array} skins </span>
<span class="cm">         *      A list of skin names. Each entry must match a class name of a</span>
<span class="cm">         *      skin (case sensitive).</span>
<span class="cm">         * @param {Array} connectors </span>
<span class="cm">         *      A list of connectors identifiers (e.g. MasterSlave1Master).</span>
<span class="cm">         *      Schema: &lt;connectorName&gt;&lt;connectorId&gt;&lt;connectorRole&gt;</span>
<span class="cm">         * @return {Module} </span>
<span class="cm">         *      The reference to the registered module.</span>
<span class="cm">         */</span>
        <span class="nx">registerModule</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$node</span><span class="p">,</span> <span class="nx">modName</span><span class="p">,</span> <span class="nx">skins</span><span class="p">,</span> <span class="nx">connectors</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">modules</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="nx">modName</span> <span class="o">=</span> <span class="nx">modName</span> <span class="o">||</span> <span class="kc">null</span><span class="p">;</span>
            <span class="nx">skins</span> <span class="o">=</span> <span class="nx">skins</span> <span class="o">||</span> <span class="p">[];</span>
            <span class="nx">connectors</span> <span class="o">=</span> <span class="nx">connectors</span> <span class="o">||</span> <span class="p">[];</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">modName</span> <span class="o">&amp;&amp;</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">])</span> <span class="p">{</span>
                <span class="c1">// Generate a unique ID for every module</span>
                <span class="kd">var</span> <span class="nx">modId</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
                <span class="nx">$node</span><span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nx">modId</span><span class="p">);</span>

                <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">](</span><span class="nx">$node</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">,</span> <span class="nx">modId</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">skins</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">skinName</span> <span class="o">=</span> <span class="nx">skins</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

                    <span class="k">if</span> <span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">][</span><span class="nx">skinName</span><span class="p">])</span> <span class="p">{</span>
                        <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">]</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">].</span><span class="nx">getDecoratedModule</span><span class="p">(</span><span class="nx">modName</span><span class="p">,</span> <span class="nx">skinName</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">connectors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">registerConnection</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Registers a connection between a module and a connector.</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerConnection</span>
<span class="cm">         * @param {String} connector </span>
<span class="cm">         *      The full connector name (e.g. MasterSlave1Slave).</span>
<span class="cm">         * @param {Module} component </span>
<span class="cm">         *      The module instance.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">registerConnection</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">connector</span><span class="p">,</span> <span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">connectorType</span> <span class="o">=</span> <span class="nx">connector</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[0-9]+[a-zA-Z]*$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                    <span class="nx">connectorId</span> <span class="o">=</span> <span class="nx">connector</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[a-zA-Z]*$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[a-zA-Z]*/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                    <span class="nx">connectorRole</span> <span class="o">=</span> <span class="nx">connector</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[a-zA-Z]*[0-9]*/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">connectorId</span> <span class="o">===</span> <span class="s1">&#39;*&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">connectorRole</span> <span class="o">===</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Add the component to the wildcard component stack</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">])</span> <span class="p">{</span>
                    <span class="c1">// Instantiate the appropriate connector if it does not</span>
            <span class="c1">// exist yet</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">connectorType</span> <span class="o">===</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span><span class="p">(</span><span class="nx">connectorId</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span><span class="p">[</span><span class="nx">connectorType</span><span class="p">])</span> <span class="p">{</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span><span class="p">[</span><span class="nx">connectorType</span><span class="p">](</span><span class="nx">connectorId</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">])</span> <span class="p">{</span>
                    <span class="cm">/**</span>
<span class="cm">                     * The connector observes the component and attaches it as</span>
<span class="cm">                     * an observer.</span>
<span class="cm">                     */</span>
                    <span class="nx">component</span><span class="p">.</span><span class="nx">attachConnector</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]);</span>

                    <span class="cm">/**</span>
<span class="cm">                     * The component wants to be informed over state changes. </span>
<span class="cm">                     * It registers it as connector member.</span>
<span class="cm">                     */</span>
                    <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">].</span><span class="nx">registerComponent</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">connectorRole</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * The sandbox function</span>
<span class="cm">     * The sandbox is used as a central point to get resources from, grant</span>
<span class="cm">     * permissions, etc.  It is shared between all modules.</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Sandbox</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Sandbox</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the Sandbox.</span>
<span class="cm">         *</span>
<span class="cm">         * @method init</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         * @constructor</span>
<span class="cm">         * @param {Applicaton} application </span>
<span class="cm">         *      The application reference</span>
<span class="cm">         * @param {Object} config </span>
<span class="cm">         *      The configuration</span>
<span class="cm">         */</span>
        <span class="nx">init</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">application</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>

            <span class="cm">/**</span>
<span class="cm">             * The application</span>
<span class="cm">             *</span>
<span class="cm">             * @property application</span>
<span class="cm">             * @type Application</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">application</span> <span class="o">=</span> <span class="nx">application</span><span class="p">;</span>

            <span class="cm">/**</span>
<span class="cm">             * The configuration.</span>
<span class="cm">             *</span>
<span class="cm">             * @property config</span>
<span class="cm">             * @type Object</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">config</span><span class="p">;</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the requested javascript dependencies.</span>
<span class="cm">             *</span>
<span class="cm">             * @property dependencies</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the afterBinding module callbacks.</span>
<span class="cm">             *</span>
<span class="cm">             * @property afterBindingCallbacks</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">afterBindingCallbacks</span> <span class="o">=</span> <span class="p">[];</span>


            <span class="cm">/**</span>
<span class="cm">             * Contains the first script node on the page.</span>
<span class="cm">             *</span>
<span class="cm">             * @property firstScript</span>
<span class="cm">             * @type Node</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">firstScript</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Adds (register and start) all modules in the given context scope.</span>
<span class="cm">         *</span>
<span class="cm">         * @method addModules</span>
<span class="cm">         * @param {jQuery} $ctx </span>
<span class="cm">         *      The jQuery context.</span>
<span class="cm">         * @return {Array} </span>
<span class="cm">         *      A list containing the references of the registered modules.</span>
<span class="cm">         */</span>
        <span class="nx">addModules</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">modules</span> <span class="o">=</span> <span class="p">[],</span>
                    <span class="nx">application</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">$ctx</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Register modules</span>
                <span class="nx">modules</span> <span class="o">=</span> <span class="nx">application</span><span class="p">.</span><span class="nx">registerModules</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">);</span>

                <span class="c1">// Start modules</span>
                <span class="nx">application</span><span class="p">.</span><span class="nx">start</span><span class="p">(</span><span class="nx">modules</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nx">modules</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Removes a module by module instances.</span>
<span class="cm">         * This stops and unregisters a module through a module instance.</span>
<span class="cm">         *</span>
<span class="cm">         * @method removeModules</span>
<span class="cm">         * @param {Array} modules </span>
<span class="cm">         *      A list containting the module instances to remove.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">removeModules</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">application</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Stop modules</span>
                <span class="nx">application</span><span class="p">.</span><span class="nx">stop</span><span class="p">(</span><span class="nx">modules</span><span class="p">);</span>

                <span class="c1">// Unregister modules</span>
                <span class="nx">application</span><span class="p">.</span><span class="nx">unregisterModules</span><span class="p">(</span><span class="nx">modules</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Gets the appropriate module for the given ID.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getModuleById</span>
<span class="cm">         * @param {int} id </span>
<span class="cm">         *      The module ID</span>
<span class="cm">         * @return {Module} </span>
<span class="cm">         *      The appropriate module</span>
<span class="cm">         */</span>
        <span class="nx">getModuleById</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">application</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">application</span><span class="p">.</span><span class="nx">modules</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">application</span><span class="p">.</span><span class="nx">modules</span><span class="p">[</span><span class="nx">id</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;the module with the id &#39;</span> <span class="o">+</span> <span class="nx">id</span> <span class="o">+</span> 
                                <span class="s1">&#39; does not exist&#39;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Gets the application config.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getConfig</span>
<span class="cm">         * @return {Object} </span>
<span class="cm">         *      The configuration object</span>
<span class="cm">         */</span>
        <span class="nx">getConfig</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Gets an application config param.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getConfigParam</span>
<span class="cm">         * @param {String} name </span>
<span class="cm">         *      The param name</span>
<span class="cm">         * @return {mixed} </span>
<span class="cm">         *      The appropriate configuration param</span>
<span class="cm">         */</span>
        <span class="nx">getConfigParam</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">name</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;the config param &#39;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39; does not exist&#39;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Loads a requested dependency (if not already loaded).</span>
<span class="cm">         *</span>
<span class="cm">         * @method loadDependency</span>
<span class="cm">         * @param {String} dependency </span>
<span class="cm">         *      The dependency (e.g. swfobject.js)</span>
<span class="cm">         * @param {String} type </span>
<span class="cm">         *      The dependency type (plugin | library | util | url)</span>
<span class="cm">         * @param {Function} callback </span>
<span class="cm">         *      The callback to execute after the dependency has successfully</span>
<span class="cm">         *      loaded.</span>
<span class="cm">         * @param {String} phase </span>
<span class="cm">         *      The module phase where the dependency is needed</span>
<span class="cm">         *      (e.g. beforeBinding, onBinding).</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">loadDependency</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dependency</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">phase</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
            <span class="c1">// None indicates that it is not a dependency for a specific phase</span>

            <span class="nx">phase</span> <span class="o">=</span> <span class="nx">phase</span> <span class="o">||</span> <span class="s1">&#39;none&#39;</span><span class="p">;</span>             
        <span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">||</span> <span class="s1">&#39;plugin&#39;</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">]</span> <span class="o">&amp;&amp;</span> 
            <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;requested&#39;</span><span class="p">)</span> <span class="p">{</span> 
                <span class="cm">/**</span>
<span class="cm">                 * Requested (but loading ist not finished) the module should</span>
<span class="cm">                 * be notified, if the dependency has loaded</span>
<span class="cm">                 */</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nx">callback</span><span class="p">(</span><span class="nx">phase</span><span class="p">);</span>
                <span class="p">});</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">]</span> <span class="o">&amp;&amp;</span> 
            <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;loaded&#39;</span><span class="p">)</span> <span class="p">{</span> 
                <span class="c1">// Loading finished</span>
                <span class="nx">callback</span><span class="p">(</span><span class="nx">phase</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nx">state</span><span class="o">:</span> <span class="s1">&#39;requested&#39;</span><span class="p">,</span>
                    <span class="nx">callbacks</span><span class="o">:</span> <span class="p">[]</span>
                <span class="p">};</span>

                <span class="kd">var</span> <span class="nx">path</span><span class="p">;</span>

                <span class="k">switch</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="s1">&#39;library&#39;</span><span class="o">:</span>
                    <span class="k">case</span> <span class="s1">&#39;plugin&#39;</span><span class="o">:</span>
                    <span class="k">case</span> <span class="s1">&#39;util&#39;</span><span class="o">:</span>
                        <span class="nx">path</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">dependencyPath</span><span class="p">[</span><span class="nx">type</span><span class="p">];</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="s1">&#39;url&#39;</span><span class="o">:</span>
                        <span class="nx">path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="s1">&#39;default&#39;</span><span class="o">:</span>
                        <span class="nx">path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// Load the appropriate dependency</span>
                <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">),</span>
                    <span class="nx">firstScript</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstScript</span><span class="p">;</span>
                
                <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">path</span> <span class="o">+</span> <span class="nx">dependency</span><span class="p">;</span>

                <span class="nx">script</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">script</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">readyState</span> <span class="o">=</span> <span class="nx">script</span><span class="p">.</span><span class="nx">readyState</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">readyState</span> <span class="o">||</span> <span class="nx">readyState</span> <span class="o">==</span> <span class="s1">&#39;loaded&#39;</span> 
                    <span class="o">||</span> <span class="nx">readyState</span> <span class="o">==</span> <span class="s1">&#39;complete&#39;</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;loaded&#39;</span><span class="p">;</span>
                        <span class="nx">callback</span><span class="p">(</span><span class="nx">phase</span><span class="p">);</span>

                        <span class="c1">// Notify the other modules with this dependency</span>
                        <span class="kd">var</span> <span class="nx">callbacks</span> <span class="o">=</span> <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">callbacks</span><span class="p">;</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">]();</span>
                        <span class="p">}</span>

                        <span class="c1">// Handle memory leak in IE</span>
                        <span class="nx">script</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">script</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">};</span>

                <span class="nx">firstScript</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">script</span><span class="p">,</span> <span class="nx">firstScript</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Collects the module status messages and handles the callbacks.</span>
<span class="cm">         * This means that it is ready for afterBinding.</span>
<span class="cm">         *</span>
<span class="cm">         * @method readyForAfterBinding</span>
<span class="cm">         * @param {Function} callback </span>
<span class="cm">         *      The afterBinding module callback</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">readyForAfterBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">afterBindingCallbacks</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">afterBindingCallbacks</span><span class="p">;</span>

            <span class="c1">// Add the callback to the stack</span>
            <span class="nx">afterBindingCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>

            <span class="c1">// Check whether all modules are ready for the afterBinding phase</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">.</span><span class="nx">modules</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> 
            <span class="nx">afterBindingCallbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">afterBindingCallbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">afterBindingCallbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">]();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Base class for the different modules.</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Module</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the Module.</span>
<span class="cm">         *</span>
<span class="cm">         * @method init</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         * @constructor</span>
<span class="cm">         * @param {jQuery} $ctx </span>
<span class="cm">         *      The jQuery context</span>
<span class="cm">         * @param {Sandbox} sandbox </span>
<span class="cm">         *      The sandbox to get the resources from</span>
<span class="cm">         * @param {String} modId </span>
<span class="cm">         *      The Unique module ID</span>
<span class="cm">         */</span>
        <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">,</span> <span class="nx">sandbox</span><span class="p">,</span> <span class="nx">modId</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/**</span>
<span class="cm">             * Contains the module context.</span>
<span class="cm">             *</span>
<span class="cm">             * @property $ctx</span>
<span class="cm">             * @type jQuery</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span> <span class="o">=</span> <span class="nx">$ctx</span><span class="p">;</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the unique module ID.</span>
<span class="cm">             *</span>
<span class="cm">             * @property modId</span>
<span class="cm">             * @type String</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">modId</span> <span class="o">=</span> <span class="nx">modId</span><span class="p">;</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the attached connectors.</span>
<span class="cm">             *</span>
<span class="cm">             * @property connectors</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the dependency counter for the different phases.</span>
<span class="cm">             *</span>
<span class="cm">             * @property dependencyCounter</span>
<span class="cm">             * @type Object</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nx">beforeBinding</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="cm">/**</span>
<span class="cm">                 * The following counters have to be at least zero, so that</span>
<span class="cm">                 * the onBinding callback is loaded as a dependency for</span>
<span class="cm">                 * onBinding and the onBinding phase is completed for </span>
<span class="cm">                 * afterBinding.</span>
<span class="cm">                 */</span>
                <span class="nx">onBinding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="nx">afterBinding</span><span class="o">:</span> <span class="mi">1</span> 
            <span class="p">};</span>

            <span class="cm">/**</span>
<span class="cm">             * The sandbox to get the resources from.</span>
<span class="cm">             *</span>
<span class="cm">             * @property sandbox</span>
<span class="cm">             * @type Sandbox</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span> <span class="o">=</span> <span class="nx">sandbox</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Template method to start (i.e. init) the module.</span>
<span class="cm">         * This method provides some hook functions which could be overridden</span>
<span class="cm">         * from the concrete implementation.</span>
<span class="cm">         *</span>
<span class="cm">         * @method start</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">start</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Call the hook method dependecies from the specific implementation</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">initBeforeBinding</span><span class="p">();</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Template method to stop the module.</span>
<span class="cm">         *</span>
<span class="cm">         * @method stop</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">stop</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">$ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span><span class="p">;</span>
            
            <span class="c1">// Remove all bound events and associated jQuery data</span>
            <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="nx">$ctx</span><span class="p">).</span><span class="nx">unbind</span><span class="p">().</span><span class="nx">removeData</span><span class="p">();</span>
            <span class="nx">$ctx</span><span class="p">.</span><span class="nx">unbind</span><span class="p">().</span><span class="nx">removeData</span><span class="p">();</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the beforeBinding phase.</span>
<span class="cm">         *</span>
<span class="cm">         * @method initBeforeBinding</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">initBeforeBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="cm">/** </span>
<span class="cm">             * Start the beforeBinding phase if there are no dependency for</span>
<span class="cm">             * this phase</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">checkDependencies</span><span class="p">(</span><span class="s1">&#39;beforeBinding&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="cm">/**</span>
<span class="cm">                 * Call the hook method beforeBinding from the concrete</span>
<span class="cm">                 * implementation because there might be some ajax calls, the</span>
<span class="cm">                 * bindEvents method must be called from the beforeBinding</span>
<span class="cm">                 * function after it has been run.</span>
<span class="cm">                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">beforeBinding</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">that</span><span class="p">.</span><span class="nx">beforeBinding</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nx">that</span><span class="p">.</span><span class="nx">beforeBindingCallback</span><span class="p">();</span>
                    <span class="p">});</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">that</span><span class="p">.</span><span class="nx">beforeBindingCallback</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Callback for the before binding phase.</span>
<span class="cm">         * </span>
<span class="cm">         * @method beforeBindingCallback</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">beforeBindingCallback</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Decrement the dependency counter for the onBinding phase</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">.</span><span class="nx">onBinding</span><span class="o">--</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">initOnBinding</span><span class="p">();</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the onBinding phase.</span>
<span class="cm">         *</span>
<span class="cm">         * @method initOnBinding</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">initOnBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="cm">/** </span>
<span class="cm">             * Start the onBinding phase if there are no dependencies for this</span>
<span class="cm">             * phase.</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">checkDependencies</span><span class="p">(</span><span class="s1">&#39;onBinding&#39;</span><span class="p">,</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// Call the hook method bindEvents from the concrete implementation</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">onBinding</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">that</span><span class="p">.</span><span class="nx">onBinding</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="c1">// Decrement the dependency counter for the afterBinding phase</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">.</span><span class="nx">afterBinding</span><span class="o">--</span><span class="p">;</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">initAfterBinding</span><span class="p">();</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the afterBinding phase.</span>
<span class="cm">         *</span>
<span class="cm">         * @method initAfterBinding</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">initAfterBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="cm">/**</span>
<span class="cm">             * Start the afterBinding phase if there are no dependencies for</span>
<span class="cm">             * this phase</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">checkDependencies</span><span class="p">(</span><span class="s1">&#39;afterBinding&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="cm">/** </span>
<span class="cm">                 * Inform the sandbox that the module is ready for the</span>
<span class="cm">                 * afterBinding phase.</span>
<span class="cm">                 */</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">readyForAfterBinding</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

                    <span class="cm">/**</span>
<span class="cm">                     * Call the hook method afterBinding from the concrete</span>
<span class="cm">                     * implementation</span>
<span class="cm">                     */</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">afterBinding</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">that</span><span class="p">.</span><span class="nx">afterBinding</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">});</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Checks the dependency load state of the given phase.</span>
<span class="cm">         * Initializes the appropriate phase if all dependencies are loaded.</span>
<span class="cm">         *</span>
<span class="cm">         * @method checkDependencies</span>
<span class="cm">         * @param {String} phase </span>
<span class="cm">         *      The phase to check / initialize</span>
<span class="cm">         * @param {Function} callback </span>
<span class="cm">         *      The callback to execute if all dependencies were loaded</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">checkDependencies</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">phase</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">[</span><span class="nx">phase</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Execute the callback</span>
                <span class="nx">callback</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Manages the required dependencies.</span>
<span class="cm">         *</span>
<span class="cm">         * @method require</span>
<span class="cm">         * @param {String} dependency </span>
<span class="cm">         *      The dependency (e.g. swfobject.js)</span>
<span class="cm">         * @param {String} type </span>
<span class="cm">         *      The dependency type (library | plugin | util | url)</span>
<span class="cm">         * @param {String} phase </span>
<span class="cm">         *      The module phase where the dependency is needed</span>
<span class="cm">         *      (e.g. beforeBinding, onBinding)</span>
<span class="cm">         * @param {boolean} executeCallback </span>
<span class="cm">         *      Indicates whether the phase callback should be executed or not.</span>
<span class="cm">         *      This is useful for dependencies that provide their own callback</span>
<span class="cm">         *      mechanism.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">require</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dependency</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">phase</span><span class="p">,</span> <span class="nx">executeCallback</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">||</span> <span class="s1">&#39;plugin&#39;</span><span class="p">;</span>
            <span class="nx">phase</span> <span class="o">=</span> <span class="nx">phase</span> <span class="o">||</span> <span class="s1">&#39;onBinding&#39;</span><span class="p">;</span>
            <span class="nx">executeCallback</span> <span class="o">=</span> <span class="nx">executeCallback</span> <span class="o">===</span> <span class="kc">false</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="kc">true</span><span class="p">;</span>

            <span class="c1">// Increment the dependency counter</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">[</span><span class="nx">phase</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// Proxy the callback to the outermost decorator</span>
            <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">proxy</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">executeCallback</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

                    <span class="cm">/**</span>
<span class="cm">                     * Decrement the dependency counter for the appropriate</span>
<span class="cm">                     * phase.</span>
<span class="cm">                     */</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">[</span><span class="nx">phase</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                    <span class="nx">that</span><span class="p">[</span><span class="s1">&#39;init&#39;</span> <span class="o">+</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span><span class="p">.</span><span class="nb">String</span><span class="p">.</span><span class="nx">capitalize</span><span class="p">(</span><span class="nx">phase</span><span class="p">)]();</span>
                <span class="p">}</span>
            <span class="p">},</span> <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">getModuleById</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">modId</span><span class="p">));</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">loadDependency</span><span class="p">(</span><span class="nx">dependency</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">phase</span><span class="p">);</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Notifies all attached connectors about changes.</span>
<span class="cm">         *</span>
<span class="cm">         * @method fire</span>
<span class="cm">         * @param {String} state </span>
<span class="cm">         *      The new state</span>
<span class="cm">         * @param {Object} data </span>
<span class="cm">         *      The data to provide to your connected modules</span>
<span class="cm">         * @param {Function} defaultAction </span>
<span class="cm">         *      The default action to perform</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">fire</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">defaultAction</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
                <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">;</span>
            
            <span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span> <span class="o">||</span><span class="p">{};</span>
            <span class="nx">state</span> <span class="o">=</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span><span class="p">.</span><span class="nb">String</span><span class="p">.</span><span class="nx">capitalize</span><span class="p">(</span><span class="nx">state</span><span class="p">);</span>

            <span class="nx">$</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">connectors</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">connector</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

                <span class="c1">// Callback combining the defaultAction and the afterAction</span>
                <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">defaultAction</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">defaultAction</span><span class="p">();</span>
                    <span class="p">}</span>
                    <span class="nx">connector</span><span class="p">.</span><span class="nx">notify</span><span class="p">(</span><span class="nx">that</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span> <span class="o">+</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
                <span class="p">};</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">connector</span><span class="p">.</span><span class="nx">notify</span><span class="p">(</span><span class="nx">that</span><span class="p">,</span> <span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">))</span> <span class="p">{</span>
                    <span class="nx">callback</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">});</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">connectors</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">defaultAction</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">defaultAction</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Attaches a connector (observer).</span>
<span class="cm">         *</span>
<span class="cm">         * @method attachConnector</span>
<span class="cm">         * @param {Connector} connector </span>
<span class="cm">         *      The connector to attach</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">attachConnector</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">connector</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">connector</span><span class="p">);</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Decorates itself with the given skin.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getDecoratedModule</span>
<span class="cm">         * @param {String} module </span>
<span class="cm">         *      The name of the module</span>
<span class="cm">         * @param {String} skin </span>
<span class="cm">         *      The name of the skin</span>
<span class="cm">         * @return {Module} </span>
<span class="cm">         *      The decorated module</span>
<span class="cm">         */</span>
        <span class="nx">getDecoratedModule</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module</span><span class="p">,</span> <span class="nx">skin</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">module</span><span class="p">][</span><span class="nx">skin</span><span class="p">])</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">decorator</span> <span class="o">=</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">module</span><span class="p">][</span><span class="nx">skin</span><span class="p">];</span>

                <span class="cm">/*</span>
<span class="cm">                 * Sets the prototype object to the module.</span>
<span class="cm">                 * So the &quot;non-decorated&quot; functions will be called on the module</span>
<span class="cm">                 * without implementing the whole module interface.</span>
<span class="cm">                 */</span>
                <span class="nx">decorator</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
                <span class="nx">decorator</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">module</span><span class="p">][</span><span class="nx">skin</span><span class="p">];</span>

                <span class="k">return</span> <span class="k">new</span> <span class="nx">decorator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Base class for the different connectors.</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Connector</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the Connector.</span>
<span class="cm">         *</span>
<span class="cm">         * @method init</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         * @constructor</span>
<span class="cm">         * @param {String} connectorId </span>
<span class="cm">         *      The unique connector ID</span>
<span class="cm">         * @param {Object} connectorId</span>
<span class="cm">         */</span>
        <span class="nx">init</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">connectorId</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectorId</span> <span class="o">=</span> <span class="nx">connectorId</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">components</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Registers a component.</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerComponent</span>
<span class="cm">         * @param {Module} component </span>
<span class="cm">         *      The module to register</span>
<span class="cm">         * @param {String} role </span>
<span class="cm">         *      The role of the module (e.g. master, slave etc.)</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">registerComponent</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">role</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">role</span> <span class="o">=</span> <span class="nx">role</span> <span class="o">||</span> <span class="s1">&#39;standard&#39;</span><span class="p">;</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                <span class="s1">&#39;component&#39;</span><span class="o">:</span> <span class="nx">component</span><span class="p">,</span>
                <span class="s1">&#39;role&#39;</span><span class="o">:</span> <span class="nx">role</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Unregisters a component.</span>
<span class="cm">         *</span>
<span class="cm">         * @method unregisterComponent</span>
<span class="cm">         * @param {Module} component </span>
<span class="cm">         *      The module to unregister</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">unregisterComponent</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">components</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">components</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">id</span> <span class="k">in</span> <span class="nx">components</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span> <span class="o">===</span> <span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">delete</span> <span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Notifies all registered components about a state change </span>
<span class="cm">         * This can be be overriden in the specific connectors.</span>
<span class="cm">         *</span>
<span class="cm">         * @method notify</span>
<span class="cm">         * @param {Module} component </span>
<span class="cm">         *      The module that sends the state change</span>
<span class="cm">         * @param {String} state </span>
<span class="cm">         *      The component&#39;s state</span>
<span class="cm">         * @param {Object} data </span>
<span class="cm">         *      Contains the state relevant data (if any)</span>
<span class="cm">         * @param {Function} callback </span>
<span class="cm">         *      The callback function, it can be executed after an asynchronous</span>
<span class="cm">         *      action.</span>
<span class="cm">         * @return {boolean} </span>
<span class="cm">         *      Indicates whether the default action should be excuted or not</span>
<span class="cm">         */</span>
        <span class="nx">notify</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="cm">/**</span>
<span class="cm">             * Gives the components the ability to prevent the default- and</span>
<span class="cm">             * afteraction from the events by returning false in the</span>
<span class="cm">             * on&lt;Event&gt;-Handler.</span>
<span class="cm">             */</span>
            
            <span class="kd">var</span> <span class="nx">proceed</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
                <span class="nx">components</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">components</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">id</span> <span class="k">in</span> <span class="nx">components</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span> <span class="o">!==</span> <span class="nx">component</span> <span class="o">&amp;&amp;</span> <span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span><span class="p">[</span><span class="nx">state</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span><span class="p">[</span><span class="nx">state</span><span class="p">](</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">proceed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nx">proceed</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Contains utility functions for several tasks.</span>
<span class="cm"> */</span>
<span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span> <span class="o">=</span> <span class="p">{};</span>

<span class="cm">/**</span>
<span class="cm"> * Contains utility functions for string concerning tasks.</span>
<span class="cm"> *</span>
<span class="cm"> * @author Remo Brunschwiler</span>
<span class="cm"> * @namespace Tc.Utils</span>
<span class="cm"> * @class String</span>
<span class="cm"> * @static</span>
<span class="cm"> */</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span><span class="p">.</span><span class="nb">String</span> <span class="o">=</span> <span class="p">{</span>
        <span class="cm">/**</span>
<span class="cm">         * Capitalizes the first letter of the given string.</span>
<span class="cm">         *</span>
<span class="cm">         * @method capitalize</span>
<span class="cm">         * @param {String} str </span>
<span class="cm">         *      The original string</span>
<span class="cm">         * @return {String} </span>
<span class="cm">         *      The capitalized string</span>
<span class="cm">         */</span>
        <span class="nx">capitalize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Capitalize the first letter</span>
            <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">().</span><span class="nx">concat</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">};</span>   
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>
</pre></div>
                    </div>
			</div>
		</div>
		<div class="yui-b">
            <div class="nav">

                    <div id="moduleList" class="module">
                        <h4>Modules</h4>
                        <ul class="content">
                                <li class="selected"><a href="module_Tc.html" title="Tc">Tc</a></li>
                        </ul>
                    </div>

                    <div id="classList" class="module">
                        <h4>Classes</h4>
                        <ul class="content">
                                <li class=""><a href="Tc.Application.html" title="Tc.Application">Tc.Application</a></li>
                                <li class=""><a href="Tc.Config.html" title="Tc.Config">Tc.Config</a></li>
                                <li class=""><a href="Tc.Connector.html" title="Tc.Connector">Tc.Connector</a></li>
                                <li class=""><a href="Tc.Module.html" title="Tc.Module">Tc.Module</a></li>
                                <li class=""><a href="Tc.Sandbox.html" title="Tc.Sandbox">Tc.Sandbox</a></li>
                                <li class=""><a href="Tc.Utils.String.html" title="Tc.Utils.String">Tc.Utils.String</a></li>
                        </ul>
                    </div>

                    <div id="fileList" class="module">
                        <h4>Files</h4>
                        <ul class="content">        
                                <li class="selected"><a href="terrific-1.0.0.js.html" title="terrific-1.0.0.js">terrific-1.0.0.js</a></li>
                        </ul>
                    </div>





            </div>
		</div>
	</div>
	<div id="ft">
        <hr />
        Copyright &copy; 2011 TerrificJS, Remo Brunschwiler. All rights reserved.
	</div>
</div>
<script type="text/javascript">
    ALL_YUI_PROPS = [{"url": "Tc.Application.html#property_$ctx", "access": "", "host": "Tc.Application", "type": "property", "name": "$ctx"}, {"url": "Tc.Module.html#property_$ctx", "access": "", "host": "Tc.Module", "type": "property", "name": "$ctx"}, {"url": "Tc.Sandbox.html#method_addModules", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "addModules"}, {"url": "Tc.Sandbox.html#property_afterBindingCallbacks", "access": "", "host": "Tc.Sandbox", "type": "property", "name": "afterBindingCallbacks"}, {"url": "Tc.Sandbox.html#property_application", "access": "", "host": "Tc.Sandbox", "type": "property", "name": "application"}, {"url": "Tc.Module.html#method_attachConnector", "access": "", "host": "Tc.Module", "type": "method", "name": "attachConnector"}, {"url": "Tc.Module.html#method_beforeBindingCallback", "access": "", "host": "Tc.Module", "type": "method", "name": "beforeBindingCallback"}, {"url": "Tc.Application.html#event_beforeClasses  \n.mod Indicates that it is a base module (default \n-> no javascript need to be involved). Must occur\nexcactly once.Change", "access": "", "host": "Tc.Application", "type": "event", "name": "beforeClasses  \n.mod Indicates that it is a base module (default \n-> no javascript need to be involved). Must occur\nexcactly once.Change"}, {"url": "Tc.Utils.String.html#method_capitalize", "access": "", "host": "Tc.Utils.String", "type": "method", "name": "capitalize"}, {"url": "Tc.Module.html#method_checkDependencies", "access": "", "host": "Tc.Module", "type": "method", "name": "checkDependencies"}, {"url": "Tc.Application.html#property_classes\nA module can have three types of classes:", "access": "", "host": "Tc.Application", "type": "property", "name": "classes\nA module can have three types of classes:"}, {"url": "Tc.Application.html#config_classes  \n.mod Indicates that it is a base module (default \n-> no javascript need to be involved). Must occur\nexcactly once.", "access": "", "host": "Tc.Application", "type": "config", "name": "classes  \n.mod Indicates that it is a base module (default \n-> no javascript need to be involved). Must occur\nexcactly once."}, {"url": "Tc.Application.html#event_classes  \n.mod Indicates that it is a base module (default \n-> no javascript need to be involved). Must occur\nexcactly once.Change", "access": "", "host": "Tc.Application", "type": "event", "name": "classes  \n.mod Indicates that it is a base module (default \n-> no javascript need to be involved). Must occur\nexcactly once.Change"}, {"url": "Tc.Application.html#property_config", "access": "", "host": "Tc.Application", "type": "property", "name": "config"}, {"url": "Tc.Sandbox.html#property_config", "access": "", "host": "Tc.Sandbox", "type": "property", "name": "config"}, {"url": "Tc.Application.html#property_connectors", "access": "", "host": "Tc.Application", "type": "property", "name": "connectors"}, {"url": "Tc.Module.html#property_connectors", "access": "", "host": "Tc.Module", "type": "property", "name": "connectors"}, {"url": "Tc.Sandbox.html#property_dependencies", "access": "", "host": "Tc.Sandbox", "type": "property", "name": "dependencies"}, {"url": "Tc.Module.html#property_dependencyCounter", "access": "", "host": "Tc.Module", "type": "property", "name": "dependencyCounter"}, {"url": "Tc.Config.html#property_dependencyPath", "access": "", "host": "Tc.Config", "type": "property", "name": "dependencyPath"}, {"url": "Tc.Module.html#method_fire", "access": "", "host": "Tc.Module", "type": "method", "name": "fire"}, {"url": "Tc.Sandbox.html#property_firstScript", "access": "", "host": "Tc.Sandbox", "type": "property", "name": "firstScript"}, {"url": "Tc.Sandbox.html#method_getConfig", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "getConfig"}, {"url": "Tc.Sandbox.html#method_getConfigParam", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "getConfigParam"}, {"url": "Tc.Module.html#method_getDecoratedModule", "access": "", "host": "Tc.Module", "type": "method", "name": "getDecoratedModule"}, {"url": "Tc.Sandbox.html#method_getModuleById", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "getModuleById"}, {"url": "Tc.Application.html#method_init", "access": "", "host": "Tc.Application", "type": "method", "name": "init"}, {"url": "Tc.Sandbox.html#method_init", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "init"}, {"url": "Tc.Module.html#method_init", "access": "", "host": "Tc.Module", "type": "method", "name": "init"}, {"url": "Tc.Connector.html#method_init", "access": "", "host": "Tc.Connector", "type": "method", "name": "init"}, {"url": "Tc.Module.html#method_initAfterBinding", "access": "", "host": "Tc.Module", "type": "method", "name": "initAfterBinding"}, {"url": "Tc.Module.html#method_initBeforeBinding", "access": "", "host": "Tc.Module", "type": "method", "name": "initBeforeBinding"}, {"url": "Tc.Module.html#method_initOnBinding", "access": "", "host": "Tc.Module", "type": "method", "name": "initOnBinding"}, {"url": "Tc.Sandbox.html#method_loadDependency", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "loadDependency"}, {"url": "Tc.Module.html#property_modId", "access": "", "host": "Tc.Module", "type": "property", "name": "modId"}, {"url": "Tc.Application.html#property_modules", "access": "", "host": "Tc.Application", "type": "property", "name": "modules"}, {"url": "Tc.Connector.html#method_notify", "access": "", "host": "Tc.Connector", "type": "method", "name": "notify"}, {"url": "Tc.Module.html#property_onBinding", "access": "", "host": "Tc.Module", "type": "property", "name": "onBinding"}, {"url": "Tc.Connector.html#property_proceed", "access": "", "host": "Tc.Connector", "type": "property", "name": "proceed"}, {"url": "Tc.Sandbox.html#method_readyForAfterBinding", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "readyForAfterBinding"}, {"url": "Tc.Connector.html#method_registerComponent", "access": "", "host": "Tc.Connector", "type": "method", "name": "registerComponent"}, {"url": "Tc.Application.html#method_registerConnection", "access": "", "host": "Tc.Application", "type": "method", "name": "registerConnection"}, {"url": "Tc.Application.html#method_registerModule", "access": "", "host": "Tc.Application", "type": "method", "name": "registerModule"}, {"url": "Tc.Application.html#method_registerModules", "access": "", "host": "Tc.Application", "type": "method", "name": "registerModules"}, {"url": "Tc.Sandbox.html#method_removeModules", "access": "", "host": "Tc.Sandbox", "type": "method", "name": "removeModules"}, {"url": "Tc.Module.html#method_require", "access": "", "host": "Tc.Module", "type": "method", "name": "require"}, {"url": "Tc.Application.html#property_sandbox", "access": "", "host": "Tc.Application", "type": "property", "name": "sandbox"}, {"url": "Tc.Module.html#property_sandbox", "access": "", "host": "Tc.Module", "type": "property", "name": "sandbox"}, {"url": "Tc.Application.html#method_start", "access": "", "host": "Tc.Application", "type": "method", "name": "start"}, {"url": "Tc.Module.html#method_start", "access": "", "host": "Tc.Module", "type": "method", "name": "start"}, {"url": "Tc.Application.html#method_stop", "access": "", "host": "Tc.Application", "type": "method", "name": "stop"}, {"url": "Tc.Module.html#method_stop", "access": "", "host": "Tc.Module", "type": "method", "name": "stop"}, {"url": "Tc.Connector.html#method_unregisterComponent", "access": "", "host": "Tc.Connector", "type": "method", "name": "unregisterComponent"}, {"url": "Tc.Application.html#method_unregisterModule", "access": "", "host": "Tc.Application", "type": "method", "name": "unregisterModule"}, {"url": "Tc.Application.html#property_wildcardComponents", "access": "", "host": "Tc.Application", "type": "property", "name": "wildcardComponents"}];
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/Users/rbrunschwiler/Documents/github/terrificjs/dist/terrific.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/T.Application.html">T.Application</a></li>
            
                <li><a href="../classes/T.Connector.html">T.Connector</a></li>
            
                <li><a href="../classes/T.Module.html">T.Module</a></li>
            
                <li><a href="../classes/T.Sandbox.html">T.Sandbox</a></li>
            
                <li><a href="../classes/T.Utils.html">T.Utils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/T.html">T</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: /Users/rbrunschwiler/Documents/github/terrificjs/dist/terrific.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(root, factory) {
  if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {
    define([], factory);
  } else if (typeof exports === &#x27;object&#x27;) {
    module.exports = factory();
  } else {
    root.T = factory();
  }
}(this, function() {
/*!
 * TerrificJS modularizes your frontend code by solely relying on naming conventions.
 * http://terrifically.org
 *
 * @copyright   Copyright (c) 2015 Remo Brunschwiler
 * @license     Licensed under MIT license
 * @version     3.0.0-beta.1
 */

/**
 * @module T
 */

/**
 * Responsible for application-wide issues such as the creation of modules.
 *
 * @author Remo Brunschwiler
 * @namespace T
 * @class Application
 *
 * @constructor
 * @param {Node} ctx
 *      The context node
 * @param {Object} config
 *      The configuration
 */
/* global Sandbox, Module, Utils */
function Application(ctx, config) {
	// validate params
	if (!ctx &amp;&amp; !config) {
		// both empty
		ctx = document;
		config = {};
	}
	else if (config instanceof Node) {
		// reverse order of arguments
		var tmpConfig = config;
		config = ctx;
		ctx = tmpConfig;
	}
	else if (!(ctx instanceof Node) &amp;&amp; !config) {
		// only config is given
		config = ctx;
		ctx = document;
	}
	else if (ctx instanceof Node &amp;&amp; !config) {
		// only ctx is given
		config = {};
	}

	/**
	 * The context node.
	 *
	 * @property _ctx
	 * @type Node
	 */
	this._ctx = ctx;

	/**
	 * The sandbox to get the resources from.
	 * The singleton is shared between all modules.
	 *
	 * @property _sandbox
	 * @type Sandbox
	 */
	this._sandbox = new Sandbox(this, config);

	/**
	 * Contains references to all modules on the page.
	 *
	 * @property _modules
	 * @type Object
	 */
	this._modules = {};

	/**
	 * The next unique module id to use.
	 *
	 * @property id
	 * @type Number
	 */
	this._id = 1;
}

/**
 * Register modules within the context
 * Automatically registers all modules within the context,
 * as long as the modules use the naming conventions.
 *
 * @method registerModules
 * @param {Node} ctx
 *      The context node
 * @return {Object}
 *      A collection containing the registered modules
 */
Application.prototype.registerModules = function (ctx) {
	var modules = {};

	ctx = ctx || this._ctx;

	this._sandbox.dispatch(&#x27;t.register.start&#x27;);

	// check childrens
	var nodes = [].slice.call(ctx.querySelectorAll(&#x27;[data-t-name]&#x27;));

	// check context itself
	if(ctx.matches(&#x27;[data-t-name]&#x27;)) {
		nodes.unshift(ctx);
	}

	// check childrens
	nodes.forEach(function (ctx) {

		/*
		 * A module can have different data attributes.
		 * See below for possible values.
		 */

		/*
		 * @config data-t-name=&quot;{mod-name}&quot;
		 *
		 * Example: data-t-name=&quot;foo&quot;
		 * Indicates that the module Foo should be bound.
		 */

		/*
		 * @config data-t-namespace=&quot;{namespace}&quot;
		 *
		 * Example: data-t-skin=&quot;App.Components&quot;
		 * The namespace of the module. Optional.
		 */

		/*
		 * @config data-t-skin=&quot;{skin-name}&quot;
		 *
		 * Example: data-t-skin=&quot;bar&quot;
		 * Indicates that the module Foo should be decorated by the skin Bar.
		 * Multiple skins should be comma-separated. Optional.
		 */
		var module = this.registerModule(ctx, ctx.getAttribute(&#x27;data-t-name&#x27;), ctx.getAttribute(&#x27;data-t-skin&#x27;), ctx.getAttribute(&#x27;data-t-namespace&#x27;));

		if (module) {
			modules[module.id] = module;
		}
	}.bind(this));

	this._sandbox.dispatch(&#x27;t.register.end&#x27;);

	return modules;
};

/**
 * Unregisters the modules given by the module instances.
 *
 * @method unregisterModules
 * @param {Object} modules
 *      A collection containing the modules to unregister
 */
Application.prototype.unregisterModules = function (modules) {
	modules = modules || this._modules;

	this._sandbox.dispatch(&#x27;t.unregister.start&#x27;);

	// unregister the given modules
	for (var id in modules) {
		if (modules.hasOwnProperty(id)) {
			delete this._modules[id];
		}
	}

	this._sandbox.dispatch(&#x27;t.unregister.end&#x27;);
};

/**
 * Starts (intializes) the registered modules.
 *
 * @method start
 * @param {Object} modules
 *      A collection of modules to start
 * @return {Promise}
 *      The synchronize Promise
 */
Application.prototype.start = function (modules) {
	modules = modules || this._modules;

	var promises = [];

	this._sandbox.dispatch(&#x27;t.start&#x27;);

	// start the modules
	function getPromise(id) {
		return new Promise(function (resolve) {
			modules[id].start(function() {
				resolve();
			});
		});
	}

	for (var id in modules) {
		if (modules.hasOwnProperty(id)) {
			promises.push(getPromise(id));
		}
	}

	// synchronize modules
	var all = Promise.all(promises);
	all.then(function () {
		this._sandbox.dispatch(&#x27;t.sync&#x27;);
	}.bind(this))
		.catch(function (error) {
			throw Error(&#x27;Synchronizing the modules failed: &#x27; + error);
		});

	return all;
};

/**
 * Stops the registered modules.
 *
 * @method stop
 * @param {Object} modules
 *      A collection of modules to stop
 */
Application.prototype.stop = function (modules) {
	modules = modules || this._modules;

	this._sandbox.dispatch(&#x27;t.stop&#x27;);

	// stop the modules
	for (var id in modules) {
		if (modules.hasOwnProperty(id)) {
			modules[id].stop();
		}
	}
};

/**
 * Registers a module.
 *
 * @method registerModule
 * @param {Node} ctx
 *      The context node
 * @param {String} mod
 *      The module name. It must match the class name of the module
 * @param {Array} skins
 *      A list of skin names. Each entry must match a class name of a skin
 * @param {String} namespace
 *      The module namespace
 * @return {Module}
 *      The reference to the registered module
 */
Application.prototype.registerModule = function (ctx, mod, skins, namespace) {
	var modules = this._modules;

	// validate params
	mod = Utils.capitalize(Utils.camelize(mod));

	if(Utils.isString(skins)) {
		if(window[skins]) {
			// skins param is the namespace
			namespace = window[skins];
			skins = null;
		}
		else {
			// convert string to array
			skins = skins.split(&#x27;,&#x27;);
		}
	}
	else if(!Array.isArray(skins) &amp;&amp; Utils.isObject(skins)) {
		// skins is the namespace object
		namespace = skins;
		skins = null;
	}

	skins = skins || [];
	skins = skins.map(function (skin) {
		return Utils.capitalize(Utils.camelize(skin.trim()));
	});

	namespace = namespace || Module;

	if (namespace[mod]) {
		// assign the module a unique id
		var id = this._id++;
		ctx.setAttribute(&#x27;data-t-id&#x27;, id);

		// instantiate module
		modules[id] = new namespace[mod](ctx, this._sandbox);

		// decorate it
		for(var i = 0, len = skins.length; i &lt; len; i++) {
			var skin = skins[i];

			if (namespace[mod][skin]) {
				namespace[mod][skin](modules[id]);
			}
		}

		return modules[id];
	}

	this._sandbox.dispatch(&#x27;t.missing&#x27;, ctx, mod, skins, namespace);

	return null;
};

/**
 * Gets the appropriate module for the given ID.
 *
 * @method getModuleById
 * @param {int} id
 *      The module ID
 * @return {Module}
 *      The appropriate module
 */
Application.prototype.getModuleById = function (id) {
	if (this._modules[id]) {
		return this._modules[id];
	}
	else {
		throw Error(&#x27;The module with the id &#x27; + id +
		&#x27; does not exist&#x27;);
	}
};

/**
 * The sandbox is used as a central point to get resources from, add modules etc.
 * It is shared between all modules.
 *
 * @author Remo Brunschwiler
 * @namespace T
 * @class Sandbox
 *
 * @constructor
 * @param {Application} application
 *      The application reference
 * @param {Object} config
 *      The configuration
 */
function Sandbox(application, config) {
	/**
	 * The application.
	 *
	 * @property _application
	 * @type Application
	 */
	this._application = application;

	/**
	 * The configuration.
	 *
	 * @property config
	 * @type Object
	 */
	this._config = config;

	/**
	 * Contains references to all module connectors.
	 *
	 * @property _connectors
	 * @type Array
	 */
	this._connectors = [];
}

/**
 * Adds (register and start) all modules in the given context scope.
 *
 * @method addModules
 * @param {Node} ctx
 *      The context node
 * @return {Object}
 *      A collection containing the registered modules
 */
Sandbox.prototype.addModules = function (ctx) {
	var modules = [],
		application = this._application;

	if (ctx instanceof Node) {
		// register modules
		modules = application.registerModules(ctx);

		// start modules
		application.start(modules);
	}

	return modules;
};

/**
 * Removes a module by module instances.
 * This stops and unregisters a module through a module instance.
 *
 * @method removeModules
 * @param {any} modules
 *      A collection of module to remove | Node context to look for registered modules in.
 * @return {Sandbox}
 */
Sandbox.prototype.removeModules = function (modules) {
	var application = this._application;

	if (modules instanceof Node) {
		// get modules
		var tmpModules = [];

		var fragment = document.createDocumentFragment();
		fragment.appendChild(modules);

		[].forEach.call(fragment.querySelectorAll(&#x27;[data-t-name]&#x27;), function (ctx) {
			// check for instance
			var id = ctx.getAttribute(&#x27;data-t-id&#x27;);

			if (id !== undefined) {
				var module = this.getModuleById(id);

				if (module) {
					tmpModules.push(module);
				}
			}
		}.bind(this));

		modules = tmpModules;
	}

	if (Array.isArray(modules)) {
		// stop modules – let the module clean itself
		application.stop(modules);

		// unregister modules – clean up the application
		application.unregisterModules(modules);
	}

	return this;
};

/**
 * Gets the appropriate module for the given ID.
 *
 * @method getModuleById
 * @param {int} id
 *      The module ID
 * @return {Module}
 *      The appropriate module
 */
Sandbox.prototype.getModuleById = function (id) {
	return this._application.getModuleById(id);
};

/**
 * Gets the application config.
 *
 * @method getConfig
 * @return {Object}
 *      The configuration object
 */
Sandbox.prototype.getConfig = function () {
	return this._config;
};

/**
 * Gets an application config param.
 *
 * @method getConfigParam
 * @param {String} name
 *      The param name
 * @return {any}
 *      The appropriate configuration param
 */
Sandbox.prototype.getConfigParam = function (name) {
	var config = this._config;

	if (config[name] !== undefined) {
		return config[name];
	}
	else {
		throw Error(&#x27;The config param &#x27; + name + &#x27; does not exist&#x27;);
	}
};

/**
 * Adds a connector instance.
 *
 * @method addConnector
 * @param {Connector} connector
 *      The connector
 * @return {Sandbox}
 */
Sandbox.prototype.addConnector = function (connector) {
	this._connectors.push(connector);
	return this;
};

/**
 * Removes a connector instance.
 *
 * @method addConnector
 * @param {Connector} connector
 *      The connector
 * @return {Sandbox}
 */
Sandbox.prototype.removeConnector = function (connector) {
	var connectors = this._connectors;
	for (var i = 0, len = connectors.length; i &lt; len; i++) {
		if (connectors[i] === connector) {
			connectors.splice(i, 1);
			break;
		}
	}
	return this;
};

/**
 * Dispatches the event with the given arguments to the attached connectors.
 *
 * @method dispatch
 * @param {Mixed} ...
 * @return {Sandbox}
 */
Sandbox.prototype.dispatch = function () {
	var connectors = this._connectors;

	for(var i = 0, len = connectors.length; i &lt; len; i++) {
		var connector = connectors[i];
		connector.handle.apply(connector, arguments);
	}

	return this;
};
/**
 * Base class for the different modules.
 *
 * @author Remo Brunschwiler
 * @namespace T
 * @class Module
 *
 * @constructor
 * @param {Node} ctx
 *      The context node
 * @param {Sandbox} sandbox
 *      The sandbox to get the resources from
 */
/* global Connector */
function Module(ctx, sandbox) {
	/**
	 * Contains the context node.
	 *
	 * @property ctx
	 * @type Node
	 */
	this._ctx = ctx;

	/**
	 * The sandbox to get the resources from.
	 *
	 * @property _sandbox
	 * @type Sandbox
	 */
	this._sandbox = sandbox;

	/**
	 * The emitter.
	 *
	 * @property _events
	 * @type Connector
	 */
	this._events = new Connector(sandbox);
}

/**
 * Template method to start the module.
 *
 * @method start
 * @param {Function} callback
 *      The synchronize callback
 */
Module.prototype.start = function (callback) {
	callback();
};

/**
 * Template method to stop the module.
 *
 * @method stop
 */
Module.prototype.stop = function () {
	this._events.disconnect();
};

/**
 * Responsible for inter-module communication.
 * Classic EventEmitter Api. Heavily inspired by https://github.com/component/emitter
 *
 * @author Remo Brunschwiler
 * @namespace T
 * @class Connector
 *
 * @constructor
 *
 * @param {Sandbox} sandbox
 *      The sandbox instance
 */
function Connector(sandbox) {
	/**
	 * The listeners.
	 *
	 * @property _listeners
	 * @type Object
	 */
	this._listeners = {};

	/**
	 * The sandbox instance.
	 *
	 * @property _sandbox
	 * @type Sandbox
	 */
	this._sandbox = sandbox;

	/**
	 * Indicates whether the instance is connected to the sandbox.
	 *
	 * @property _connected
	 * @type Boolean
	 */
	this._connected = false;
}

/**
 * Adds a listener for the given event.
 *
 * @method on
 * @param {String} event
 * @param {Function} listener
 * @return {Connector}
 */
Connector.prototype.on = Connector.prototype.addListener = function (event, listener) {
	this.connect();

	(this._listeners[&#x27;$&#x27; + event] = this._listeners[&#x27;$&#x27; + event] || []).push(listener);
	return this;
};

/**
 * Adds a listener that will be invoked a single
 * time and automatically removed afterwards.
 *
 * @method once
 * @param {String} event
 * @param {Function} listener
 * @return {Connector}
 */
Connector.prototype.once = function (event, listener) {
	this.connect();

	function on() {
		this.off(event, on);
		listener.apply(this, arguments);
	}

	on.listener = listener;
	this.on(event, on);
	return this;
};

/**
 * Remove the given listener for the given event or all
 * registered listeners.
 *
 * @method off
 * @param {String} event
 * @param {Function} listener
 * @return {Connector}
 */
Connector.prototype.off = Connector.prototype.removeListener = Connector.prototype.removeAllListeners = function (event, listener) {
	// all
	if (arguments.length === 0) {
		this._listeners = {};
		return this;
	}

	// specific event
	var listeners = this._listeners[&#x27;$&#x27; + event];
	if (!listeners) {
		return this;
	}

	// remove all listeners
	if (arguments.length === 1) {
		delete this._listeners[&#x27;$&#x27; + event];
		return this;
	}

	// remove specific listener
	var cb;
	for (var i = 0, len = listeners.length; i &lt; len; i++) {
		cb = listeners[i];
		if (cb === listener || cb.listener === listener) {
			listeners.splice(i, 1);
			break;
		}
	}

	return this;
};

/**
 * Dispatches event to the sandbox.
 *
 * @method emit
 * @param {Mixed} ...
 * @return {Connector}
 */
Connector.prototype.emit = function () {
	this.connect();

	// dispatches event to the sandbox
	this._sandbox.dispatch.apply(this._sandbox, arguments);

	return this;
};

/**
 * Handles dispatched event from sandbox.
 *
 * @method handle
 * @param {String} event
 * @param {Mixed} ...
 * @return {Connector}
 */
Connector.prototype.handle = function (event) {
	var args = [].slice.call(arguments, 1),
		listeners = this._listeners[&#x27;$&#x27; + event];

	if (listeners) {
		listeners = listeners.slice(0);
		for (var i = 0, len = listeners.length; i &lt; len; ++i) {
			listeners[i].apply(this, args);
		}
	}

	return this;
};


/**
 * Return array of listeners for the given event.
 *
 * @method listeners
 * @param {String} event
 * @return {Array}
 */
Connector.prototype.listeners = function (event) {
	return this._listeners[&#x27;$&#x27; + event] || [];
};

/**
 * Check if this connector has listeners.
 *
 * @method hasListeners
 * @param {String} event
 * @return {Boolean}
 */
Connector.prototype.hasListeners = function (event) {
	return !!this.listeners(event).length;
};

/**
 * Connect instance to the sandbox.
 *
 * @method connect
 * @return {Connector}
 */
Connector.prototype.connect = function () {
	if (!this._connected) {
		this._sandbox.addConnector(this);
		this._connected = true;
	}

	return this;
};

/**
 * Disconnect instance from the sandbox.
 *
 * @method disconnect
 * @return {Connector}
 */
Connector.prototype.disconnect = function () {
	if (this._connected) {
		this._sandbox.removeConnector(this);
		this._connected = false;
	}

	return this;
};


/**
 * Utility functions.
 *
 * @author Remo Brunschwiler
 * @namespace T
 * @class Utils
 * @static
 */
/* jshint unused: false */
var Utils = {
	/**
	 * Capitalizes the first letter of the given string.
	 *
	 * @method capitalize
	 * @param {String} str
	 *      The original string
	 * @return {String}
	 *      The capitalized string
	 */
	capitalize: function (str) {
		return str.substr(0, 1).toUpperCase().concat(str.substr(1));
	},

	/**
	 * Camelizes the given string.
	 *
	 * @method camelize
	 * @param {String} str
	 *      The original string
	 * @return {String}
	 *      The camelized string
	 */
	camelize: function (str) {
		return str.replace(/(\-[A-Za-z])/g, function ($1) {
			return $1.toUpperCase().replace(&#x27;-&#x27;, &#x27;&#x27;);
		});
	},

	/**
	 * Check whether the given object is a string.
	 *
	 * @method isString
	 * @param {Object} obj
	 *      The object to check
	 * @return {Boolean}
	 */
	isString: function(obj) {
		return Object.prototype.toString.call(obj) === &#x27;[object String]&#x27;;
	},

	/**
	 * Check whether the given param is an object.
	 *
	 * @method isObject
	 * @param {Object} obj
	 *      The object to check
	 * @return {Boolean}
	 */

	isObject : function (obj) {
		return obj === Object(obj);
	}
};

/* global Application, Sandbox, Module, Connector, Utils */
/* jshint unused: false */
var T = {
	Application: Application,
	Sandbox: Sandbox,
	Module: Module,
	Connector: Connector,
	Utils: Utils,
	version: &#x27;3.0.0-beta.1&#x27;
};
return T;
}));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
